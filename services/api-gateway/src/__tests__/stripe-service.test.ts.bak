/**
 * Stripe Service Tests
 *
 * Tests for Stripe integration including checkout, portal, and webhooks.
 */

import {
  verifyWebhookSignature,
  handleWebhookEvent,
  getSubscriptionInfo,
  isStripeConfigured,
} from '../stripe-service';

// Mock the persistence layer
jest.mock('@aivo/persistence', () => ({
  getSubscriptionByTenantId: jest.fn(),
  getSubscriptionByStripeCustomerId: jest.fn(),
  getSubscriptionByStripeSubscriptionId: jest.fn(),
  upsertSubscription: jest.fn(),
  updateSubscriptionByStripeSubscriptionId: jest.fn(),
  createPayment: jest.fn(),
  getPaymentByStripeInvoiceId: jest.fn(),
  updatePaymentByStripeInvoiceId: jest.fn(),
}));

// Mock Stripe
jest.mock('stripe', () => {
  return jest.fn().mockImplementation(() => ({
    checkout: {
      sessions: {
        create: jest.fn(),
      },
    },
    billingPortal: {
      sessions: {
        create: jest.fn(),
      },
    },
    webhooks: {
      constructEvent: jest.fn(),
    },
  }));
});

import * as persistence from '@aivo/persistence';

const mockPersistence = persistence as jest.Mocked<typeof persistence>;

describe('Stripe Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Reset environment variables
    process.env.STRIPE_SECRET_KEY = undefined;
    process.env.STRIPE_WEBHOOK_SECRET = undefined;
  });

  describe('isStripeConfigured', () => {
    it('should return false when STRIPE_SECRET_KEY is not set', () => {
      // Since the module is loaded once, we test based on initial state
      // In a real scenario, we'd need module isolation
      expect(typeof isStripeConfigured()).toBe('boolean');
    });
  });

  describe('getSubscriptionInfo', () => {
    it('should return default info for non-existent subscription', async () => {
      mockPersistence.getSubscriptionByTenantId.mockResolvedValue(null);

      const result = await getSubscriptionInfo('tenant-1');

      expect(result.status).toBe('NONE');
      expect(result.tier).toBe('FREE');
      expect(result.canAccessPlatform).toBe(false);
      expect(result.requiresPayment).toBe(true);
    });

    it('should return active subscription info', async () => {
      mockPersistence.getSubscriptionByTenantId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'ACTIVE',
        tier: 'PRO',
        stripeCustomerId: 'cus_123',
        stripeSubscriptionId: 'sub_123',
        stripePriceId: 'price_123',
        trialStartedAt: null,
        trialEndsAt: null,
        hasUsedTrial: false,
        pilotStartedAt: null,
        pilotEndsAt: null,
        hasUsedPilot: false,
        pilotMaxLearners: null,
        pilotMaxSchools: null,
        currentPeriodStart: new Date('2024-01-01'),
        currentPeriodEnd: new Date('2024-02-01'),
        cancelledAt: null,
        cancelAtPeriodEnd: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        tenant: {
          id: 'tenant-1',
          name: 'Test Tenant',
          type: 'individual',
        },
      } as any);

      const result = await getSubscriptionInfo('tenant-1');

      expect(result.status).toBe('ACTIVE');
      expect(result.tier).toBe('PRO');
      expect(result.canAccessPlatform).toBe(true);
      expect(result.requiresPayment).toBe(false);
      expect(result.stripeCustomerId).toBe('cus_123');
    });

    it('should correctly identify trial as accessible', async () => {
      mockPersistence.getSubscriptionByTenantId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'TRIAL_ACTIVE',
        tier: 'FREE',
        hasUsedTrial: true,
        trialStartedAt: new Date(),
        trialEndsAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        tenant: {
          id: 'tenant-1',
          name: 'Test Tenant',
          type: 'individual',
        },
      } as any);

      const result = await getSubscriptionInfo('tenant-1');

      expect(result.status).toBe('TRIAL_ACTIVE');
      expect(result.canAccessPlatform).toBe(true);
      expect(result.requiresPayment).toBe(false);
    });

    it('should correctly identify pilot as accessible', async () => {
      mockPersistence.getSubscriptionByTenantId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'PILOT_ACTIVE',
        tier: 'ENTERPRISE',
        hasUsedPilot: true,
        pilotStartedAt: new Date(),
        pilotEndsAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        pilotMaxLearners: 500,
        pilotMaxSchools: 10,
        tenant: {
          id: 'tenant-1',
          name: 'Test District',
          type: 'district',
        },
      } as any);

      const result = await getSubscriptionInfo('tenant-1');

      expect(result.status).toBe('PILOT_ACTIVE');
      expect(result.canAccessPlatform).toBe(true);
      expect(result.requiresPayment).toBe(false);
    });

    it('should correctly identify expired trial as requiring payment', async () => {
      mockPersistence.getSubscriptionByTenantId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'TRIAL_EXPIRED',
        tier: 'FREE',
        hasUsedTrial: true,
        tenant: {
          id: 'tenant-1',
          name: 'Test Tenant',
          type: 'individual',
        },
      } as any);

      const result = await getSubscriptionInfo('tenant-1');

      expect(result.status).toBe('TRIAL_EXPIRED');
      expect(result.canAccessPlatform).toBe(false);
      expect(result.requiresPayment).toBe(true);
    });

    it('should correctly identify past due as requiring payment', async () => {
      mockPersistence.getSubscriptionByTenantId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'PAST_DUE',
        tier: 'PRO',
        stripeCustomerId: 'cus_123',
        tenant: {
          id: 'tenant-1',
          name: 'Test Tenant',
          type: 'individual',
        },
      } as any);

      const result = await getSubscriptionInfo('tenant-1');

      expect(result.status).toBe('PAST_DUE');
      expect(result.canAccessPlatform).toBe(false);
      expect(result.requiresPayment).toBe(true);
    });

    it('should correctly identify cancelled as requiring payment', async () => {
      mockPersistence.getSubscriptionByTenantId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'CANCELLED',
        tier: 'PRO',
        cancelledAt: new Date(),
        tenant: {
          id: 'tenant-1',
          name: 'Test Tenant',
          type: 'individual',
        },
      } as any);

      const result = await getSubscriptionInfo('tenant-1');

      expect(result.status).toBe('CANCELLED');
      expect(result.canAccessPlatform).toBe(false);
      expect(result.requiresPayment).toBe(true);
    });
  });

  describe('verifyWebhookSignature', () => {
    it('should fail when Stripe is not configured', () => {
      const result = verifyWebhookSignature('payload', 'signature');

      expect(result.success).toBe(false);
      expect(result.error).toContain('not configured');
    });
  });

  describe('handleWebhookEvent', () => {
    it('should handle checkout.session.completed', async () => {
      const mockEvent = {
        type: 'checkout.session.completed',
        data: {
          object: {
            id: 'cs_123',
            customer: 'cus_123',
            subscription: 'sub_123',
            metadata: {
              tenantId: 'tenant-1',
              tier: 'PRO',
            },
          },
        },
      } as any;

      mockPersistence.upsertSubscription.mockResolvedValue({} as any);

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(true);
      expect(result.eventType).toBe('checkout.session.completed');
      expect(mockPersistence.upsertSubscription).toHaveBeenCalledWith(
        'tenant-1',
        expect.objectContaining({
          stripeCustomerId: 'cus_123',
          stripeSubscriptionId: 'sub_123',
          status: 'ACTIVE',
          tier: 'PRO',
        }),
      );
    });

    it('should handle invoice.paid', async () => {
      const mockEvent = {
        type: 'invoice.paid',
        data: {
          object: {
            id: 'in_123',
            customer: 'cus_123',
            subscription: 'sub_123',
            amount_paid: 2999,
            currency: 'usd',
            payment_intent: 'pi_123',
            number: 'INV-001',
            invoice_pdf: 'https://stripe.com/invoice.pdf',
            hosted_invoice_url: 'https://stripe.com/invoice',
          },
        },
      } as any;

      mockPersistence.getSubscriptionByStripeCustomerId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
      } as any);
      mockPersistence.getPaymentByStripeInvoiceId.mockResolvedValue(null);
      mockPersistence.createPayment.mockResolvedValue({} as any);

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(true);
      expect(result.eventType).toBe('invoice.paid');
      expect(mockPersistence.createPayment).toHaveBeenCalledWith(
        expect.objectContaining({
          subscriptionId: 'sub-1',
          stripeInvoiceId: 'in_123',
          amount: 2999,
          currency: 'usd',
          status: 'succeeded',
        }),
      );
    });

    it('should handle invoice.payment_failed', async () => {
      const mockEvent = {
        type: 'invoice.payment_failed',
        data: {
          object: {
            id: 'in_123',
            customer: 'cus_123',
            subscription: 'sub_123',
            amount_due: 2999,
            currency: 'usd',
            number: 'INV-001',
            last_finalization_error: {
              message: 'Card declined',
            },
          },
        },
      } as any;

      mockPersistence.getSubscriptionByStripeCustomerId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
      } as any);
      mockPersistence.getPaymentByStripeInvoiceId.mockResolvedValue(null);
      mockPersistence.upsertSubscription.mockResolvedValue({} as any);
      mockPersistence.createPayment.mockResolvedValue({} as any);

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(true);
      expect(result.eventType).toBe('invoice.payment_failed');
      expect(mockPersistence.upsertSubscription).toHaveBeenCalledWith(
        'tenant-1',
        expect.objectContaining({
          status: 'PAST_DUE',
        }),
      );
      expect(mockPersistence.createPayment).toHaveBeenCalledWith(
        expect.objectContaining({
          status: 'failed',
          failureReason: 'Card declined',
        }),
      );
    });

    it('should handle customer.subscription.updated', async () => {
      const mockEvent = {
        type: 'customer.subscription.updated',
        data: {
          object: {
            id: 'sub_123',
            status: 'active',
            current_period_start: 1704067200, // 2024-01-01
            current_period_end: 1706745600, // 2024-02-01
            cancel_at_period_end: false,
            canceled_at: null,
            items: {
              data: [
                {
                  price: {
                    id: 'price_123',
                  },
                },
              ],
            },
          },
        },
      } as any;

      mockPersistence.getSubscriptionByStripeSubscriptionId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
      } as any);
      mockPersistence.updateSubscriptionByStripeSubscriptionId.mockResolvedValue({} as any);

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(true);
      expect(result.eventType).toBe('customer.subscription.updated');
      expect(mockPersistence.updateSubscriptionByStripeSubscriptionId).toHaveBeenCalledWith(
        'sub_123',
        expect.objectContaining({
          status: 'ACTIVE',
          cancelAtPeriodEnd: false,
        }),
      );
    });

    it('should handle customer.subscription.deleted', async () => {
      const mockEvent = {
        type: 'customer.subscription.deleted',
        data: {
          object: {
            id: 'sub_123',
            status: 'canceled',
          },
        },
      } as any;

      mockPersistence.getSubscriptionByStripeSubscriptionId.mockResolvedValue({
        id: 'sub-1',
        tenantId: 'tenant-1',
      } as any);
      mockPersistence.updateSubscriptionByStripeSubscriptionId.mockResolvedValue({} as any);

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(true);
      expect(result.eventType).toBe('customer.subscription.deleted');
      expect(mockPersistence.updateSubscriptionByStripeSubscriptionId).toHaveBeenCalledWith(
        'sub_123',
        expect.objectContaining({
          status: 'CANCELLED',
        }),
      );
    });

    it('should handle unrecognized event types gracefully', async () => {
      const mockEvent = {
        type: 'unknown.event.type',
        data: {
          object: {},
        },
      } as any;

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(true);
      expect(result.eventType).toBe('unknown.event.type');
    });

    it('should handle errors gracefully', async () => {
      const mockEvent = {
        type: 'checkout.session.completed',
        data: {
          object: {
            id: 'cs_123',
            customer: 'cus_123',
            subscription: 'sub_123',
            metadata: {
              tenantId: 'tenant-1',
              tier: 'PRO',
            },
          },
        },
      } as any;

      mockPersistence.upsertSubscription.mockRejectedValue(new Error('Database error'));

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(false);
      expect(result.error).toBe('Database error');
    });

    it('should skip checkout without tenantId', async () => {
      const mockEvent = {
        type: 'checkout.session.completed',
        data: {
          object: {
            id: 'cs_123',
            customer: 'cus_123',
            subscription: 'sub_123',
            metadata: {},
          },
        },
      } as any;

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(true);
      expect(mockPersistence.upsertSubscription).not.toHaveBeenCalled();
    });

    it('should skip invoice.paid without subscription', async () => {
      const mockEvent = {
        type: 'invoice.paid',
        data: {
          object: {
            id: 'in_123',
            customer: 'cus_123',
            subscription: null,
            amount_paid: 2999,
            currency: 'usd',
          },
        },
      } as any;

      const result = await handleWebhookEvent(mockEvent);

      expect(result.success).toBe(true);
      expect(mockPersistence.getSubscriptionByStripeCustomerId).not.toHaveBeenCalled();
    });
  });
});
