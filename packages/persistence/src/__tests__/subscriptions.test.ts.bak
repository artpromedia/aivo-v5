/**
 * Subscription Persistence Tests
 *
 * Tests for subscription CRUD operations.
 */

import {
  createSubscription,
  getSubscriptionByTenantId,
  updateSubscriptionByTenantId,
  startTrial,
  startPilot,
  cancelSubscription,
  canStartTrial,
  canStartPilot,
  createPayment,
  listPaymentsBySubscriptionId,
  getPaymentStats,
} from '../subscriptions';
import { prisma } from '../client';

// Mock the Prisma client
jest.mock('../client', () => ({
  prisma: {
    subscription: {
      findUnique: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      upsert: jest.fn(),
    },
    payment: {
      findUnique: jest.fn(),
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    },
  },
}));

const mockPrisma = prisma as jest.Mocked<typeof prisma>;

describe('Subscription Operations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('createSubscription', () => {
    it('should create a subscription with default values', async () => {
      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'NONE',
        tier: 'FREE',
        stripeCustomerId: null,
        stripeSubscriptionId: null,
        stripePriceId: null,
        trialStartedAt: null,
        trialEndsAt: null,
        hasUsedTrial: false,
        pilotStartedAt: null,
        pilotEndsAt: null,
        hasUsedPilot: false,
        pilotMaxLearners: null,
        pilotMaxSchools: null,
        currentPeriodStart: null,
        currentPeriodEnd: null,
        cancelledAt: null,
        cancelAtPeriodEnd: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      (mockPrisma.subscription.create as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await createSubscription({ tenantId: 'tenant-1' });

      expect(mockPrisma.subscription.create).toHaveBeenCalledWith({
        data: {
          tenantId: 'tenant-1',
          status: 'NONE',
          tier: 'FREE',
          stripeCustomerId: undefined,
        },
      });
      expect(result.tenantId).toBe('tenant-1');
      expect(result.status).toBe('NONE');
      expect(result.tier).toBe('FREE');
    });

    it('should create a subscription with custom status and tier', async () => {
      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'ACTIVE',
        tier: 'PRO',
        stripeCustomerId: 'cus_123',
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      (mockPrisma.subscription.create as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await createSubscription({
        tenantId: 'tenant-1',
        status: 'ACTIVE',
        tier: 'PRO',
        stripeCustomerId: 'cus_123',
      });

      expect(mockPrisma.subscription.create).toHaveBeenCalledWith({
        data: {
          tenantId: 'tenant-1',
          status: 'ACTIVE',
          tier: 'PRO',
          stripeCustomerId: 'cus_123',
        },
      });
      expect(result.status).toBe('ACTIVE');
      expect(result.tier).toBe('PRO');
    });
  });

  describe('getSubscriptionByTenantId', () => {
    it('should return subscription with tenant info', async () => {
      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'ACTIVE',
        tier: 'PRO',
        tenant: {
          id: 'tenant-1',
          name: 'Test Tenant',
          type: 'individual',
        },
      };

      (mockPrisma.subscription.findUnique as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await getSubscriptionByTenantId('tenant-1');

      expect(mockPrisma.subscription.findUnique).toHaveBeenCalledWith({
        where: { tenantId: 'tenant-1' },
        include: {
          tenant: {
            select: {
              id: true,
              name: true,
              type: true,
            },
          },
        },
      });
      expect(result?.tenant.name).toBe('Test Tenant');
    });

    it('should return null for non-existent subscription', async () => {
      (mockPrisma.subscription.findUnique as jest.Mock).mockResolvedValue(null);

      const result = await getSubscriptionByTenantId('non-existent');

      expect(result).toBeNull();
    });
  });

  describe('startTrial', () => {
    it('should start a 30-day trial', async () => {
      const now = new Date();
      const trialEndsAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'TRIAL_ACTIVE',
        tier: 'FREE',
        trialStartedAt: now,
        trialEndsAt,
        hasUsedTrial: true,
      };

      (mockPrisma.subscription.upsert as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await startTrial('tenant-1');

      expect(mockPrisma.subscription.upsert).toHaveBeenCalled();
      expect(result.status).toBe('TRIAL_ACTIVE');
      expect(result.hasUsedTrial).toBe(true);
    });

    it('should start a custom duration trial', async () => {
      const now = new Date();
      const trialEndsAt = new Date(now.getTime() + 14 * 24 * 60 * 60 * 1000);

      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'TRIAL_ACTIVE',
        tier: 'FREE',
        trialStartedAt: now,
        trialEndsAt,
        hasUsedTrial: true,
      };

      (mockPrisma.subscription.upsert as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await startTrial('tenant-1', 14);

      expect(result.status).toBe('TRIAL_ACTIVE');
    });
  });

  describe('startPilot', () => {
    it('should start a 90-day pilot with default limits', async () => {
      const now = new Date();
      const pilotEndsAt = new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000);

      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'PILOT_ACTIVE',
        tier: 'ENTERPRISE',
        pilotStartedAt: now,
        pilotEndsAt,
        hasUsedPilot: true,
        pilotMaxLearners: 500,
        pilotMaxSchools: 10,
      };

      (mockPrisma.subscription.upsert as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await startPilot('tenant-1');

      expect(mockPrisma.subscription.upsert).toHaveBeenCalled();
      expect(result.status).toBe('PILOT_ACTIVE');
      expect(result.tier).toBe('ENTERPRISE');
      expect(result.pilotMaxLearners).toBe(500);
      expect(result.pilotMaxSchools).toBe(10);
    });

    it('should start a pilot with custom limits', async () => {
      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'PILOT_ACTIVE',
        tier: 'ENTERPRISE',
        pilotMaxLearners: 1000,
        pilotMaxSchools: 20,
        hasUsedPilot: true,
      };

      (mockPrisma.subscription.upsert as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await startPilot('tenant-1', {
        maxLearners: 1000,
        maxSchools: 20,
      });

      expect(result.pilotMaxLearners).toBe(1000);
      expect(result.pilotMaxSchools).toBe(20);
    });
  });

  describe('canStartTrial', () => {
    it('should allow trial for new tenant', async () => {
      (mockPrisma.subscription.findUnique as jest.Mock).mockResolvedValue(null);

      const result = await canStartTrial('tenant-1');

      expect(result.canStart).toBe(true);
    });

    it('should deny trial if already used', async () => {
      (mockPrisma.subscription.findUnique as jest.Mock).mockResolvedValue({
        hasUsedTrial: true,
        status: 'TRIAL_EXPIRED',
      });

      const result = await canStartTrial('tenant-1');

      expect(result.canStart).toBe(false);
      expect(result.reason).toBe('Trial has already been used');
    });

    it('should deny trial if active subscription exists', async () => {
      (mockPrisma.subscription.findUnique as jest.Mock).mockResolvedValue({
        hasUsedTrial: false,
        status: 'ACTIVE',
      });

      const result = await canStartTrial('tenant-1');

      expect(result.canStart).toBe(false);
      expect(result.reason).toBe('Active subscription exists');
    });
  });

  describe('cancelSubscription', () => {
    it('should cancel immediately', async () => {
      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'CANCELLED',
        cancelledAt: new Date(),
        cancelAtPeriodEnd: false,
      };

      (mockPrisma.subscription.update as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await cancelSubscription('tenant-1', true);

      expect(mockPrisma.subscription.update).toHaveBeenCalledWith({
        where: { tenantId: 'tenant-1' },
        data: expect.objectContaining({
          status: 'CANCELLED',
          cancelAtPeriodEnd: false,
        }),
      });
      expect(result.status).toBe('CANCELLED');
    });

    it('should cancel at period end', async () => {
      const mockSubscription = {
        id: 'sub-1',
        tenantId: 'tenant-1',
        status: 'ACTIVE',
        cancelAtPeriodEnd: true,
      };

      (mockPrisma.subscription.update as jest.Mock).mockResolvedValue(mockSubscription);

      const result = await cancelSubscription('tenant-1', false);

      expect(mockPrisma.subscription.update).toHaveBeenCalledWith({
        where: { tenantId: 'tenant-1' },
        data: expect.objectContaining({
          cancelAtPeriodEnd: true,
        }),
      });
      expect(result.cancelAtPeriodEnd).toBe(true);
    });
  });
});

describe('Payment Operations', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('createPayment', () => {
    it('should create a successful payment', async () => {
      const mockPayment = {
        id: 'pay-1',
        subscriptionId: 'sub-1',
        stripeInvoiceId: 'in_123',
        amount: 2999,
        currency: 'usd',
        status: 'succeeded',
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      (mockPrisma.payment.create as jest.Mock).mockResolvedValue(mockPayment);

      const result = await createPayment({
        subscriptionId: 'sub-1',
        stripeInvoiceId: 'in_123',
        amount: 2999,
        currency: 'usd',
        status: 'succeeded',
      });

      expect(mockPrisma.payment.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          subscriptionId: 'sub-1',
          amount: 2999,
          currency: 'usd',
          status: 'succeeded',
        }),
      });
      expect(result.status).toBe('succeeded');
    });

    it('should create a failed payment with reason', async () => {
      const mockPayment = {
        id: 'pay-1',
        subscriptionId: 'sub-1',
        amount: 2999,
        currency: 'usd',
        status: 'failed',
        failureReason: 'Card declined',
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      (mockPrisma.payment.create as jest.Mock).mockResolvedValue(mockPayment);

      const result = await createPayment({
        subscriptionId: 'sub-1',
        amount: 2999,
        currency: 'usd',
        status: 'failed',
        failureReason: 'Card declined',
      });

      expect(result.status).toBe('failed');
      expect(result.failureReason).toBe('Card declined');
    });
  });

  describe('listPaymentsBySubscriptionId', () => {
    it('should return payments in descending order', async () => {
      const mockPayments = [
        { id: 'pay-2', createdAt: new Date('2024-02-01') },
        { id: 'pay-1', createdAt: new Date('2024-01-01') },
      ];

      (mockPrisma.payment.findMany as jest.Mock).mockResolvedValue(mockPayments);

      const result = await listPaymentsBySubscriptionId('sub-1');

      expect(mockPrisma.payment.findMany).toHaveBeenCalledWith({
        where: { subscriptionId: 'sub-1' },
        orderBy: { createdAt: 'desc' },
        take: 50,
        skip: 0,
      });
      expect(result).toHaveLength(2);
    });

    it('should support pagination', async () => {
      const mockPayments = [{ id: 'pay-3' }];

      (mockPrisma.payment.findMany as jest.Mock).mockResolvedValue(mockPayments);

      await listPaymentsBySubscriptionId('sub-1', { limit: 10, offset: 20 });

      expect(mockPrisma.payment.findMany).toHaveBeenCalledWith({
        where: { subscriptionId: 'sub-1' },
        orderBy: { createdAt: 'desc' },
        take: 10,
        skip: 20,
      });
    });
  });

  describe('getPaymentStats', () => {
    it('should calculate payment statistics', async () => {
      const mockPayments = [
        { amount: 2999, status: 'succeeded', createdAt: new Date('2024-02-01') },
        { amount: 2999, status: 'succeeded', createdAt: new Date('2024-01-01') },
        { amount: 2999, status: 'failed', createdAt: new Date('2024-01-15') },
        { amount: 2999, status: 'pending', createdAt: new Date('2024-02-15') },
      ];

      (mockPrisma.payment.findMany as jest.Mock).mockResolvedValue(mockPayments);

      const result = await getPaymentStats('sub-1');

      expect(result.totalPayments).toBe(4);
      expect(result.successfulPayments).toBe(2);
      expect(result.failedPayments).toBe(1);
      expect(result.pendingPayments).toBe(1);
      expect(result.totalAmount).toBe(5998); // 2999 * 2
      expect(result.lastPaymentDate).toEqual(new Date('2024-02-15'));
    });

    it('should handle empty payment list', async () => {
      (mockPrisma.payment.findMany as jest.Mock).mockResolvedValue([]);

      const result = await getPaymentStats('sub-1');

      expect(result.totalPayments).toBe(0);
      expect(result.successfulPayments).toBe(0);
      expect(result.totalAmount).toBe(0);
      expect(result.lastPaymentDate).toBeNull();
    });
  });
});
